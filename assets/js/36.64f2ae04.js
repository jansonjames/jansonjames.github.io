(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{304:function(e,t,s){"use strict";s.r(t);var n=s(13),r=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"三斜线指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三斜线指令"}},[e._v("#")]),e._v(" 三斜线指令")]),e._v(" "),t("p",[e._v("三斜线指令是包含单个XML标签的单行注释。 注释的内容会做为编译器指令使用。")]),e._v(" "),t("p",[t("strong",[e._v("三斜线指令仅可放在包含它的文件的最顶端。")]),e._v(" 一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。 如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。")]),e._v(" "),t("p",[t("code",[e._v('/// <reference path="..." />')]),e._v(" 用于声明文件间的 依赖用于声明文件间的依赖,三斜线引用告诉编译器在编译过程中要引入的额外的文件")]),e._v(" "),t("p",[e._v("三斜线引用以它们在文件里出现的顺序，使用深度优先的方式解析")]),e._v(" "),t("p",[e._v("如果指定了--noResolve编译选项，三斜线引用会被忽略；它们不会增加新文件，也不会改变给定文件的顺序。")]),e._v(" "),t("p",[t("code",[e._v('/// <reference types="..." />')]),e._v(" 声明了对某个包的依赖，对这些包的名字的解析与在 import语句里对模块名的解析类似。 可以简单地把三斜线类型引用指令当做 import声明的包。"),t("strong",[e._v("仅当在你需要写一个d.ts文件时才使用这个指令")])]),e._v(" "),t("p",[e._v("例如，把 /// "),t("reference",{attrs:{types:"node"}}),e._v("引入到声明文件，表明这个文件使用了 @types/node/index.d.ts里面声明的名字； 并且，这个包需要在编译阶段与声明文件一起被包含进来")],1),e._v(" "),t("p",[t("code",[e._v('/// <reference no-default-lib="true"/>')]),e._v(" 这个指令把一个文件标记成默认库。 你会在 lib.d.ts文件和它不同的变体的顶端看到这个注释。这个指令告诉编译器在编译过程中不要包含这个默认库（比如，lib.d.ts）。")]),e._v(" "),t("p",[t("code",[e._v("/// <amd-module />")]),e._v("默认情况下生成的AMD模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，比如 r.js。amd-module指令允许给编译器传入一个可选的模块名：")]),e._v(" "),t("div",{staticClass:"language-ts line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-ts"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[e._v('/// <amd-module name="NameModule" />')]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br")])]),t("p",[t("code",[e._v("/// <amd-dependency />")]),e._v(' 这个指令被废弃了。使用import "moduleName";语句代替。')])])}),[],!1,null,null,null);t.default=r.exports}}]);